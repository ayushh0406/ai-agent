    
"""
Test Suite for ARIA Smart Assistant (pytest version)
Advanced testing for enhanced AI agent capabilities
"""
from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Dict, List

import pytest


# ---------------------------
# Shared fixtures & utilities
# ---------------------------

@pytest.fixture(scope="session")
def have_smart_assistant():
    """
    Try importing SmartAssistant. If unavailable, skip relevant tests gracefully.
    """
    smart_runner = pytest.importorskip(
        "smart_runner",
        reason="smart_runner module not found; skipping SmartAssistant tests.",
    )
    return smart_runner


@pytest.fixture
def mock_external_deps(monkeypatch):
    """
    Mock external dependencies that require hardware, services, or API keys.
    """
    # Environment
    monkeypatch.setenv("GROQ_API_KEY", "test_key")
    monkeypatch.setenv("TTS_ENABLED", "false")

    # speech_recognition mocks
    class _DummyRecognizer:
        def __init__(self, *_, **__): ...
        def listen(self, *_, **__): return b""
        def recognize_google(self, *_, **__): return "hello"

    class _DummyMicrophone:
        def __init__(self, *_, **__): ...
        def __enter__(self): return self
        def __exit__(self, *exc): return False

    monkeypatch.setitem(pytest.sys.modules, "speech_recognition", type("M", (), {
        "Recognizer": _DummyRecognizer,
        "Microphone": _DummyMicrophone,
    }))

    # pyttsx3 mock
    class _DummyTTS:
        def setProperty(self, *_, **__): ...
        def say(self, *_, **__): ...
        def runAndWait(self): ...

    def _pyttsx3_init(*_, **__):
        return _DummyTTS()

    monkeypatch.setitem(pytest.sys.modules, "pyttsx3", type("M", (), {
        "init": staticmethod(_pyttsx3_init)
    }))

    # groq client mock
    class _DummyGroqClient:
        def __init__(self, *_, **__): ...
        def __getattr__(self, _):  # any attr access returns a dummy callable
            return lambda *a, **k: {"choices": [{"message": {"content": "ok"}}]}

    monkeypatch.setitem(pytest.sys.modules, "groq", type("M", (), {
        "Groq": _DummyGroqClient
    }))


# ---------------------------
# Smart Assistant initialization
# ---------------------------

def test_smart_assistant_initialization(have_smart_assistant, mock_external_deps):
    """ARIA Smart Assistant should initialize with name, memory, and conversation history."""
    SmartAssistant = have_smart_assistant.SmartAssistant

    assistant = SmartAssistant()

    assert getattr(assistant, "name", None) == "ARIA"
    assert hasattr(assistant, "memory"), "Assistant should have a memory attribute"
    assert hasattr(assistant, "conversation_history"), "Assistant should have conversation history"
    assert isinstance(assistant.conversation_history, list)


# ---------------------------
# Memory system
# ---------------------------

def test_memory_system_roundtrip(tmp_path: Path):
    """Memory JSON should persist and load correctly."""
    memory: Dict = {
        "preferences": {"voice_speed": "normal"},
        "frequent_tasks": [{"action": "file_creation", "count": 5}],
        "user_profile": {"name": "Test User"},
        "conversation_patterns": ["greeting", "file_ops"],
    }

    p = tmp_path / "memory.json"
    p.write_text(json.dumps(memory), encoding="utf-8")

    loaded = json.loads(p.read_text(encoding="utf-8"))

    assert "preferences" in loaded
    assert "frequent_tasks" in loaded
    assert loaded["user_profile"]["name"] == "Test User"
    assert loaded["conversation_patterns"] == ["greeting", "file_ops"]


# ---------------------------
# Smart file operations (mocked)
# ---------------------------

def test_smart_file_operations_templates():
    """Smart template selection should produce expected messaging."""
    def create_smart_file(filename: str, content: str, file_type: str, template: str) -> str:
        if template == "professional" and file_type == "email":
            _ = f"""Subject: {filename}

Dear Sir/Madam,

{content}

Best regards,
[Your Name]

---
Generated by ARIA Smart Assistant"""
            return f"‚úÖ Smart file created: {filename}.txt (Type: {file_type}, Template: {template})"
        return f"‚úÖ Basic file created: {filename}"

    r1 = create_smart_file("business_proposal", "Meeting request", "email", "professional")
    r2 = create_smart_file("project_doc", "Documentation", "markdown", "documentation")

    assert "Smart file created" in r1 and "professional" in r1 and "email" in r1
    assert r2.startswith("‚úÖ Basic file created")


# ---------------------------
# Intelligent directory analysis (mocked)
# ---------------------------

def test_intelligent_analysis_counts(tmp_path: Path):
    """Directory analyzer should count files/dirs accurately and report."""
    # Create files/dirs
    (tmp_path / "document.pdf").write_bytes(b"pdf")
    (tmp_path / "script.py").write_text("print('x')", encoding="utf-8")
    (tmp_path / "image.jpg").write_bytes(b"\xff\xd8\xff")
    (tmp_path / "subdirectory").mkdir()

    def analyze_directory(directory_path: str, analysis_type: str = "overview") -> str:
        base = Path(directory_path)
        all_paths: List[Path] = list(base.rglob("*"))
        total_files = sum(p.is_file() for p in all_paths)
        total_dirs = sum(p.is_dir() for p in all_paths)
        total_size = sum(p.stat().st_size for p in all_paths if p.is_file())  # bytes
        mb = total_size / (1024 * 1024)

        return (
            f"üìä Directory Analysis: {directory_path}\n\n"
            f"üî¢ Statistics:\n"
            f"- Files: {total_files}\n"
            f"- Directories: {total_dirs}\n"
            f"- Total Size: {mb:.2f} MB\n\n"
            f"üìÅ Structure analyzed by ARIA Smart Assistant"
        )

    report = analyze_directory(str(tmp_path))
    assert "Directory Analysis:" in report
    assert "- Files:" in report and "- Directories:" in report and "- Total Size:" in report
    # We created 3 files and 1 subdirectory
    assert "- Files: 3" in report
    assert "- Directories: 1" in report
    assert "ARIA Smart Assistant" in report


# ---------------------------
# Project structure creation (mocked)
# ---------------------------

def test_project_structure_creation():
    """Python project template should return a smart structure message."""
    def create_project_structure(project_name: str, project_type: str, features: str) -> str:
        if project_type.lower() == "python":
            structure = {
                "src": ["__init__.py"],
                "tests": ["test_main.py"],
                "docs": ["README.md"],
                "root": ["requirements.txt", "setup.py"],
            }
            assert all(k in structure for k in ("src", "tests", "docs", "root"))
            return f"üöÄ Smart project structure created: output/projects/{project_name}"
        return f"‚úÖ Project {project_name} created"

    msg = create_project_structure("test_app", "python", "AI features")
    assert "Smart project structure created" in msg
    assert msg.endswith("output/projects/test_app")


# ---------------------------
# Conversation context builder (mocked)
# ---------------------------

def test_conversation_context_builder():
    """Context builder should format last entries and cap content length."""
    history = [
        {"type": "user", "content": "Create a Python file", "timestamp": "2025-08-27T10:00:00"},
        {"type": "assistant", "content": "I created a Python file for you", "timestamp": "2025-08-27T10:00:05"},
        {"type": "user", "content": "Now analyze the directory", "timestamp": "2025-08-27T10:01:00"},
    ]

    def build_context(h: List[Dict]) -> str:
        if len(h) <= 1:
            return ""
        lines = ["Recent conversation context:"]
        for entry in h[-3:]:
            snippet = entry["content"][:50]
            lines.append(f"- {entry['type']}: {snippet}")
        return "\n".join(lines)

    ctx = build_context(history)
    assert "Recent conversation context:" in ctx
    assert "Create a Python file" in ctx
    assert "analyze the directory" in ctx


# ---------------------------
# Reminder system (mocked)
# ---------------------------

def test_reminder_system_creation():
    """Reminder creation should embed task, priority, and time."""
    def schedule_reminder(task: str, time: str, priority: str) -> str:
        reminder = {
            "task": task,
            "time": time,
            "priority": priority,
            "created": "2025-08-27T10:00:00",
        }
        # Minimal validation
        assert reminder["task"]
        assert reminder["priority"] in {"low", "medium", "high"}
        return f"‚è∞ Smart reminder set: {task} (Priority: {priority}, Time: {time})"

    msg = schedule_reminder("Team meeting", "2 PM today", "high")
    assert "Smart reminder set" in msg
    assert "Team meeting" in msg
    assert "(Priority: high, Time: 2 PM today)" in msg


# ---------------------------
# Optional: allow running as a script
# ---------------------------

if __name__ == "__main__":
    # Running via: python test_smart_assistant.py
    import pytest as _pytest
    raise SystemExit(_pytest.main([os.path.abspath(__file__)]))
